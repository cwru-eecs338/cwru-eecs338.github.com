<!DOCTYPE html>
<html>
<head>
	<title>EECS 338, Spring 2014</title>
	<link href="base-style.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="nav.js"></script>
</head>
<body onLoad="nav('nav')">
<center>
	<div class="content">
		<div>
			<h1>EECS 338: Operating Systems</h1>

			<h2>Spring, 2014</h2>
		</div>
		<div>
			<table cellspacing="20px">
				<COLGROUP width="20%"/>
				<COLGROUP width="80%"/>
				<tr>
					<td id="nav" valign="top"></td>
					<td valign="top">
						

						<h3>2014-04-01: Recitation 10</h3>

						<p>
							In this recitation, we discussed Remote Procedure Call (RPC). The basic way to execute a command on remote host
							is to use <i>ssh</i> and <i>rexec</i>. In order to call a remote user-defined procedure, we need to use RPC language to write a protocal 
							definition file. Then the command <i>rpcgen</i> is used to generate relevant stub file from the protocal definition file. A brief introduction of RPC language can 
							be found <a href="slides/remote-procedure-calls.pdf">here</a>. <a href="https://github.com/cwru-eecs338/RPC_sample_code">A sample code</a> demonstrating the basic 
							steps to write program for RPC was discussed in this recitation.
						</p>

						

						<h3>2014-03-25: Recitation 9</h3>

						<p>
							In the ninth recitation, we continued the discussion of threads. We focused on the synchronization mechanism for multiple threads. 
							As we said before, semaphore is a mechanism to synchronize the activities of multiple process. Actually it can also be used to synchronize
							the activities of multiple threads. One sample that demonstrates it can be found <a href="https://github.com/cwru-eecs338/thread_syn_semaphore">here</a>.
							Another way to synchronize threads is to use "mutex" variables, which is demonstrated by <a href="https://github.com/cwru-eecs338/thread_syn_mutex">code for producer-consumer problem</a>.
						</p>
						
						<></>

						<h3>2014-03-18: Recitation 8</h3>

						<p>
							In this recitation, we began to talked about threads. Note that the system calls for threads introduced
							here need the header file <i><pthread.h></i>. In addition, we should add the option <i>-lpthread</i> when you use gcc to compile and link the multithreaded
								program as follows: 
								<ul>
								<li>gcc -o output_file source_file -lpthread</li>
								</ul>
					
						</p>
						<p>
							The library function <i>pthread_join</i> can be used to direct the calling process to wait until specific thread is finished. However, the specified thread must be nondetached. 
							The state of detach does matter when using 	<i>pthread_join</i>, which is demonstrated by <a href="https://github.com/cwru-eecs338/thread_detached">the sample code</a>.
							If the specified thread is indeed nondetached, this thread can return some values to the thread which invoke <i>pthread_join</i> when it exits.
							There two ways to do this: one way is using the normal <i>return(void * retval)</i> statement, the other one is to use library function
							<i>void phread_exit(void * retval)</i>. The detailed usage of them is demonstrated by <a href="https://github.com/cwru-eecs338/thread_return_value">this sample code</a>.
						</p>
						<h3>2014-03-04: Recitation 7</h3>
						
						<p>
							In this recitation, we went back to the System V Semaphore. The content which were introduced in Reciation 4 
							was briefly reviewed and we continued to semaphore operation function (semop). Sample code is 
							<a href="https://github.com/cwru-eecs338/sample_code_semaphore">here</a>. 
						</p>
						
						<p>
							We also discussed System V shared memory in linux. The system calls associated with shared memory include creation call, 
							control call, operation call. Their usage is quite similar to that of System V semaphore. The major difference is that shared memory needs to be 
							attached to the data segment of specific process using the function <i>shmat</i> before it can be used by this process.
						</p>

						<h3>2014-02-25: Recitation 6</h3>

						<p>
							In sixth recitation, we discussed the Monitor and Conditional Critical Regions (CCR). Their implemenation using semaphore 
							is quite helpful for you to understand their accurate behaviors, which can be found in course slides. Plus, some problems from previous years were 
							covered, which could be found in the course website.

						<p>

						<h3>2014-02-18: Recitation 5</h3>


						<p>
						 In this recition, we discussed concurrent programming using semaphore. A glance of the book 
						 <a href="http://www.greenteapress.com/semaphores/"><i>The Little
								Book of Semaphores</i></a> (warning: the syntax in this book may not
								conform 100% to the structures presented in class) will be helpful for you to understand concurrent programming. In addition,
								the solutions of course assignments from previous year are also good materials, which you can find in the course website.
						</p>
						
						
						
						
						<h3>2014-02-11: Recitiation 4</h3>

						<p>
							In the fourth recitation, we talked about the debugger--gdb, in linux. It is quite important to get familiar with the basic
							 procedures of debugging because it is systematic way to locate the programming errors. A tutorial for gdb can be 
							 found <a href="http://cseweb.ucsd.edu/classes/fa09/cse141/tutorial_gcc_gdb.html">here</a>.
							</p>
							<p>
								In addition, we also began our discussion of Sytem V Semaphore in linux. Due to the time limit, only semaphore creation function(semget) and
								semaphore control function (semctl) were covered. Sample code which uses semaphore to synchronize the activities of two processes can be found 
							<a href="https://github.com/cwru-eecs338/sample_code_semaphore">here</a>. In this sample code, the creation, deletion, wait and sigal operation 
							on semaphore is encapsulated in a more concise way.
						</p>


						<h3>2014-02-04: Recitation 3</h3>

						<p>
							In the third recitation, we discussed process and two relevant system call in linux: fork and exec.
							fork() is used to generate a child process which share the same code with parent process but run independently. 
							The sample code for the usage of fork() is <a href="https://github.com/cwru-eecs338/fork_sample_code">here</a>. exec is actually a family of 
							linux system calls. This family consists of 6 different functions: execl, execv, execle, execve, execlp and execvp. 
							I demonstrate two sample codes one is for <a href="https://github.com/cwru-eecs338/exec_sample_code">execl</a>, the other is 
							for <a href="https://github.com/cwru-eecs338/exec_sample_code">execlp</a>.
						</p>			
							
						<p>	
							I also talked about the makefile in this recitation. The makefile is quite useful for compilation and linking, especially 
							if the program contains several source files and header files. A tutorial of makefile can be found <a href="http://mrbook.org/tutorials/make/">here</a>.
						</p>
						
						

						<h3>2014-01-28: Recitation 2</h3>

						<p>
							Cancelled due to severe cold weather.
						</p>


						<h3>2014-01-21: Recitation 1</h3>

						<p>
							The first recitation was an introduction to basic knowledge about 
							C and linux commands. Lots of students are more familiar with java. 
							The	major difference between C and java is that C is not object-orientied,
							which means that there is no concept of class in C. Because assignments in 
							this course is encouraged to be done by C language, we need to know the basic
							knowledge about C. Actually there are lots of book about C online, which is not hard to find.
							
							</p>
						<p>
							As for the basic commands in linux, I think a glance of the book <a href="relevant materials/Linux Fundamentals.pdf"><i>Linux Fundamentals</i></a> will be
							quite helpful.
						
								
						</p>
							
						


						<h3>Summary</h3>

						<p>
							This site will be updated with materials for the course during the
							semester.
							Currently, any code will be hosted at <a
								href="https://github.com/cwru-eecs338">GitHub</a>
							for easy access. </p>
					</td>
				</tr>
			</table>
		</div>
	</div>
</center>
</body>
</html>
